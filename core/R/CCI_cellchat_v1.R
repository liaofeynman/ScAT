## CCI analysis by cellchat

parser = argparse::ArgumentParser(description = 'Script for cell communication analysis')
parser$add_argument('-i', '--input', dest = 'input', default=NULL, help = 'Raw matrix file [default %(default)s]')
parser$add_argument('-m', '--meta', dest = 'meta', default=NULL, help = 'Cell labels (Recommand the cell types results generated by Annotation module) [default %(default)s]')
parser$add_argument('-s', '--species', dest = 'species', default='Human', help = 'Species of data (limit "Human", "Mouse") [default %(default)s]')
parser$add_argument('-o', '--out', dest = 'out', default=NULL, help = 'Directory to save file [default %(default)s]')
parser$add_argument('--prefix', dest = 'prefix', default = 'sample', help = 'sample ID, will be used as output prefix and seurat object ident [default %(default)s]')

# modules 
# parser$add_argument('-p', '--pathways', dest = 'pathways', default=NULL, help = 'Name of signaling pathways, 1st column for pathways [default %(default)s]')
# parser$add_argument('--mDEG', dest = 'mDEG', action='store_true', default=FALSE, help = 'Allow differential expression analysis [default %(default)s]')
# parser$add_argument('--mGCN', dest = 'mGCN', action="store_true", default=FALSE, help = 'Allow gene co-expression analysis [default %(default)s]')
# parser$add_argument('--mTop_markers', dest = 'mTop_markers', action="store_true", default=FALSE, help = 'Allow top markers analysis [default %(default)s]')

opts = parser$parse_args()
print(opts)


# # load the data  here for testing 
# rm(list=ls())
# # setwd("/home/tonyleao/wkd/data_to_viz/cellChat/script/")
# # out_dir <- "/home/tonyleao/wkd/data_to_viz/cellChat/out"
# opts <- list()
# opts$out <- "/home/tonyleao/wkd/data_to_viz/cellChat/out1"
# opts$input <- "/home/tonyleao/wkd/data_to_viz/cellChat/script/e15_matrix.txt.gz"
# opts$meta <- "/home/tonyleao/wkd/data_to_viz/cellChat/script/cell_types.txt"
# opts$species <- "Human"
# setwd("/home/tonyleao/wkd/data_to_viz/cellChat/")

### Function

#' define a function to create the cellchat object from raw matrix (*.txt.gz)
createCellChat_from_matrix <- function(opts){
    suppressMessages(library(CellChat))

    # 01 load the data and create the cellchat object
    data <- suppressWarnings(read.table(gzfile(opts$input), header = T, row.names = 1, check.names = FALSE))
    ## 增加标准化的步骤
    meta <- read.table(opts$meta, header = T, sep = "\t", )
    colnames(meta)[2] = "labels"

    # 02 transform the data from data.frame to dgCMatrix
    suppressMessages(library(Matrix))
    mat <- as.matrix(data)
    mat <- as(mat, "sparseMatrix")  

    cellchat <- suppressWarnings(createCellChat(object = mat, meta = meta, group.by = "labels"))
    
    # 03 Add cell information into meta slot of the object (Optional)
    cellchat <- addMeta(cellchat, meta = meta)
    cellchat <- setIdent(cellchat, ident.use = "labels") # set "labels" as default cell identity
    # levels(cellchat@idents) # show factor levels of the cell labels
    groupSize <- as.numeric(table(cellchat@idents)) # number of cells in each cell group
    return (cellchat)
}



#' define a functiono for preprocessing analysis
doCellChat_preprocessing <- function(cellchat, opts){
    # 01 select the CellChatDB based on the species of datasets
    if (opts$species == "Human"){
        CellChatDB <- CellChatDB.human
    } else if (opts$species == "Mouse"){
        CellChatDB <- CellChatDB.mouse
    }
    # 02 show the overview of the cell receptors
    pdf(file = file.path(opts$out, "databaseCategory.pdf"), w = 10, h = 5)
    p <- showDatabaseCategory(CellChatDB)
    print(p)
    while (!is.null(dev.list()))  dev.off()
    
    # 03 set the used database in the object
    # optional 
    # CellChatDB.use <- subsetDB(CellChatDB, search = "Secreted Signaling") # use Secreted Signaling                                                             
    CellChatDB.use <- CellChatDB # simply use the default CellChatDB
    # set the used database in the object                                                                                                                      
    cellchat@DB <- CellChatDB.use
    
    # 04 Preprocessing the expression data for cell-cell communication analysis
    cellchat <- subsetData(cellchat) # This step is necessary even if using the whole database
    future::plan("multiprocess", workers = 4) # do parallel
    cellchat <- identifyOverExpressedGenes(cellchat)
    cellchat <- identifyOverExpressedInteractions(cellchat)
    
    # project gene expression data onto PPI network (optional)
    # cellchat <- projectData(cellchat, PPI.human)

    return(cellchat)
}



#' define a function for inference of cell-cell communication network
doCellChat_infer_cell_commu_net <- function(cellchat, opts){
    # 01 Compute the communication probability and infer cellular communication network
    cellchat <- computeCommunProb(cellchat) # cost time
    # Filter out the cell-cell communication if there are only few number of cells in certain cell groups
    cellchat <- filterCommunication(cellchat, min.cells = 10)
    #Extract the inferred cellular communication network as a data frame (Not Run)
    
    # 02 Infer the cell-cell communication at a signaling pathway level
    cellchat <- computeCommunProbPathway(cellchat)
    
    # 03 Calculate the aggregated cell-cell communication network
    cellchat <- aggregateNet(cellchat)
    
    # 04 Visualize the results
    groupSize <- as.numeric(table(cellchat@idents))
    
    pdf(file = paste(opts$out, '/', opts$prefix, "_number_netVisual_circle.pdf", sep = ""))
    p <- netVisual_circle(cellchat@net$count, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = "Number of interactions")
    print (p)
    while (!is.null(dev.list()))  dev.off()
    
    pdf(file = paste(opts$out, '/', opts$prefix, "_interact_netVisual_circle.pdf", sep = ""))
    p <- netVisual_circle(cellchat@net$weight, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = "Interaction weights/strength")
    print (p)
    while (!is.null(dev.list()))  dev.off()
    
    mat <- cellchat@net$weight
    pdf(file = paste(opts$out, '/', opts$prefix, "_weight_netVisual_circle.pdf", sep = ""))
    # par(mfrow = c(3,4), xpd=TRUE)
    for (i in 1:nrow(mat)) {
      mat2 <- matrix(0, nrow = nrow(mat), ncol = ncol(mat), dimnames = dimnames(mat))
      mat2[i, ] <- mat[i, ]
      netVisual_circle(mat2, vertex.weight = groupSize, weight.scale = T, edge.weight.max = max(mat), title.name = rownames(mat)[i])
      # p<- netVisual_circle(mat2, vertex.weight = groupSize, weight.scale = T, edge.weight.max = max(mat), title.name = rownames(mat)[i])
      # print(p)
    }
    while (!is.null(dev.list()))  dev.off()
    
    return(cellchat)
}



### Main Work Flow
if ((! is.null(opts$input))  & (!is.null(opts$out))){
    if (! file.exists(opts$out)){
        dir.create(opts$out, recursive = TRUE)}
    
    cellchat <- createCellChat_from_matrix(opts)
    cellchat <- doCellChat_preprocessing(cellchat, opts)
    cellchat <- doCellChat_infer_cell_commu_net(cellchat, opts)
    saveRDS(cellchat, file = paste(opts$out, '/', opts$prefix, "_cellchat_Object.rds", sep = ""))
    
} else {
    parser$print_help()
    stop("You need to provide the following parameters: --input, --out", call.=FALSE)
}
